"--- Vundle ---"
set nocompatible " must
filetype off     " must, temporarily close, will re-open later
if(has("win32") || has("win64") || has("win95") || has("win16"))
	" windows
	set rtp+=$HOME/vimfiles/bundle/Vundle.vim
	call vundle#begin('$HOME/vimfiles/bundle')
else
	" linux
	set rtp+=~/.vim/bundle/Vundle.vim
	call vundle#begin('~/.vim/bundle')
endif
Plugin 'VundleVim/Vundle.vim'
Plugin 'tpope/vim-commentary'
Plugin 'preservim/nerdtree'
Plugin 'Vimjas/vim-python-pep8-indent'
Plugin 'jiangmiao/auto-pairs'
Plugin 'altercation/solarized'
Plugin 'tomasiser/vim-code-dark'
call vundle#end()         " must
filetype plugin indent on " must, here

"--- Settings ---"
"set nocompatible " not compatible with vi
"filetype plugin indent on " auto-detect file type
set autoread " auto-reload file if modified elsewhere
set autochdir " change working path to current path
set nobackup " don't create backup files
"set noundofile " don't create  .un~ files
if(has("win32") || has("win64") || has("win95") || has("win16"))
	set undodir=$HOME/vimundo " put .un~ files in undodir
else
	set undodir=$HOME/.vim/vimundo " put .un~ files in undodir
endif
if !isdirectory(&undodir)
    call mkdir(&undodir, "p", 0700)
endif
set hlsearch " highlight matched string
set incsearch " real-time match highlighting
set backspace=indent,eol,start
let mapleader = '\'

"--- Comment String ---"
" default: #(space)
"setlocal commentstring=#\ %s
" C/C++、Java: //(space)
autocmd FileType c,cpp,cc,java,h,hpp setlocal commentstring=//\ %s
" python、shell: #(space)
autocmd FileType python,shell setlocal commentstring=#\ %s
" lua、sql: --(space)
autocmd FileType lua,sql setlocal commentstring=--\ %s
" matlab: %(space)
autocmd FileType matlab setlocal commentstring=%\ %s
" dosbatch: @REM(space)
autocmd FileType dosbatch setlocal commentstring=\@REM\ %s

"--- Encoding ---"
set encoding=utf-8
set fileencoding=utf-8
if(has("win32") || has("win64") || has("win95") || has("win16"))
	"set termencoding=chinese " chinese is a variable
	source $VIMRUNTIME/delmenu.vim
	source $VIMRUNTIME/menu.vim
	"language messages zh_CN.utf-8
	"language messages none
	"set langmenu=none
endif
"set fileformats=unix,dos
"set fileformat=unix " use `\n`
"set fileformat=dos " use `\r\n`

"--- Tab ---"
set tabstop=4 " 1 tab = 4 spaces
set softtabstop=4
set shiftwidth=4
set smartindent
set cindent " C/C++-style indent
set noexpandtab " don't convert tabs to spaces by default
autocmd FileType python set expandtab " convert if Python

"--- Theme ---"
syntax enable
syntax on " 语法高亮
set number " show line number
set ruler " show position
set showcmd " show command
set showmode " show mode
set showmatch
"set ignorecase
set smartcase
set cursorline " highlight current line
if(has("win32") || has("win64") || has("win95") || has("win16"))
	set t_Co=256	" for codedark theme
	set t_ut=		" for codedark theme
	if has ("gui_running") " gVim
		"set cursorline
		colorscheme solarized
	else " vim
		"colorscheme codedark
		colorscheme desert
	endif
	set guifont=Consolas:h13:cANSI " English font
	set guifontwide=YouYuan:h13 " Chinese font
endif
set listchars=precedes:<,extends:>,tab:\|\ ,eol:¬,space:·
"set list " show special characters

"--- GUI Initialisation  ---"
autocmd GUIEnter * call Init_GUI()

func! Init_GUI()
    "" config window
    set guioptions-=m			" hide menu
    set guioptions-=T			" hide tool bar
    " simalt ~x					" maximise window
    set lines=32 columns=110	" window size

    "" adjust background light/dark along time
    " dawn
    let dawn_hour = 6
	let dawn_minute = 30
	" evening / night
    let night_hour = 17
    let night_minute = 30
    " now
    let hour = strftime('%H')
    let minute = strftime('%M')
    " echo hour . ":" . minute
    if hour < dawn_hour
		set background=dark
	elseif (hour == dawn_hour) && (minute < dawn_minute)
		set background=dark
	elseif hour < night_hour
        set background=light
    elseif (hour == night_hour) && (minute < night_minute)
        set background=light
    else
        set background=dark
    endif
endfunc

"--- Buffer / Window Tab ---"
" to next buffer
noremap <C-Left> gT
inoremap <C-Left> <ESC>gTa
vnoremap <C-Left> <ESC>gT
" to previous buffer
noremap <C-Right> gt
inoremap <C-Right> <ESC>gta
vnoremap <C-Right> <ESC>gt
" open new buffer (prompt)
noremap <C-t> :tabe
inoremap <C-t> <ESC>:tabe
vnoremap <C-t> <ESC>:tabe
" close current buffer
" `Ctrl-w` conflicts with window switching
"noremap <C-w> :q<CR>
"inoremap <C-w> <ESC>:q<CR>
"vnoremap <C-w> <ESC>:q<CR>

"--- NERDTree ---"
" F2 toggle open/close
noremap <F2> :NERDTreeToggle<CR>
inoremap <F2> <ESC>:NERDTreeToggle<CR>
" Ctrl + F2 open specific directory (prompt)
noremap <C-F2> :NERDTree
inoremap <C-F2> <ESC>:NERDTree

"--- Code Folding ---"
set foldenable " enable code folding
set foldmethod=manual " manual folding creating with `zf` command
" Ctrl-f toggle open/collapse <- {zo: open, zc: collapse}
nnoremap <C-f> @=((foldclosed(line('.')) < 0) ? 'zc':'zo')<CR>


"--- select all ---"
inoremap <C-a> <ESC>ggvG$
noremap <C-a> ggvG$

"--- Window Swapping ---"
nmap <silent> <leader>mw :call MarkWindowSwap()<CR>
nmap <silent> <leader>pw :call DoWindowSwap()<CR>

function! MarkWindowSwap()
    let g:markedWinNum = winnr()
endfunction

function! DoWindowSwap()
    "Mark destination
    let curNum = winnr()
    let curBuf = bufnr( "%" )
    exe g:markedWinNum . "wincmd w"
    "Switch to source and shuffle dest->source
    let markedBuf = bufnr( "%" )
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' curBuf
    "Switch to dest and shuffle source->dest
    exe curNum . "wincmd w"
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' markedBuf
endfunction


"--- F9 compile & run ---"
noremap <F9> :call Compile_iTom()<CR>
inoremap <F9> <ESC>:call Compile_iTom()<CR>

func! Compile_iTom()
	exec "w"
	if &filetype == 'c'
		exec "! gcc % -o %<"
		exec "! ./%<"
	elseif &filetype == 'cpp'
		exec "! g++ % -o %<"
		exec "! ./%<"
	elseif &filetype == 'java'
		exec "! javac %"
		exec "! java %<"
	elseif &filetype == 'python'
		exec "! python %"
	elseif &filetype == 'matlab'
		exec "! octave %"
	elseif &filetype == 'sh'
		exec "! bash %"
	elseif &filetype == 'dosbatch'
		exec "! %"
	endif
endfunc


"--- < & > ---"
"autocmd FileType xml,html inoremap < <lt>><Left>|
"	inoremap > <C-r>=Close_Pair('>')<CR>


"--- open pair ---"
"inoremap ( <C-r>=Open_Pair('(', ')')<CR>
"inoremap [ <C-r>=Open_Pair('[', ']')<CR>
"inoremap { <C-r>=Open_Pair('{', '}')<CR>

func! Open_Pair(open, close)
    let line = getline('.')
	let nxt_char = line[col('.') - 1]
    if col('.') > strlen(line) || nxt_char == ' '
		return a:open.a:close."\<Left>"
    elseif nxt_char == a:close
        return a:open
	elseif nxt_char == ')' || nxt_char == ']' || nxt_char == '}'
		return a:open.a:close."\<Left>"
	else
		return a:open
    endif
endfunc


"--- close pair ---"
"inoremap ) <C-r>=Close_Pair(')')<CR>
"inoremap ] <C-r>=Close_Pair(']')<CR>
"inoremap } <C-r>=Close_Pair('}')<CR>

func! Close_Pair(char)
	if getline('.')[col('.') - 1] == a:char
		return "\<Right>"
	else
		return a:char
	endif
endfunc


"--- quote ---"
"inoremap " <C-r>=Same_Pair('"')<CR>
"inoremap ' <C-r>=Same_Pair("'")<CR>
"inoremap ` <C-r>=Same_Pair('`')<CR>

func! Same_Pair(char)
    let line = getline('.')
	let pair = a:char.a:char."\<Left>"
    if col('.') > strlen(line) " || line[col('.') - 1] == ' '
        return pair
    elseif line[col('.') - 1] == a:char
        return "\<Right>"
    else
		let pre_char = line[col('.') - 2]
		let nxt_char = line[col('.') - 1]
		if pre_char == '(' && nxt_char == ')'
			return pair
        elseif pre_char == '[' && nxt_char == ']'
            return pair
        elseif pre_char == '{' && nxt_char == '}'
            return pair
        elseif pre_char == '<' && nxt_char == '>'
            return pair
		else
			return a:char
		endif
    endif
endfunc


"--- carrage return ---"
autocmd FileType h,c,cpp,java,python,sh inoremap <CR> <C-r>=Carrage_Return()<CR>

func! Carrage_Return()
	let line = getline('.')
	if line[col('.') - 2] == '{' && line[col('.') - 1] == '}'
		return "\<CR>\<Up>\<ESC>A\<CR>"
	else
		return "\<CR>"
    endif
endfunc


"--- backspace ---"
"inoremap <BS> <C-r>=Back_Space()<CR>

func! Back_Space()
	let line = getline('.')
	let pre_char = line[col('.') - 2]
	let nxt_char = line[col('.') - 1]
	let del_pair = "\<BS>\<DEL>"
	if pre_char == '(' && nxt_char == ')'
		return del_pair
	elseif pre_char == '[' && nxt_char == ']'
		return del_pair
	elseif pre_char == '{' && nxt_char == '}'
		return del_pair
	elseif pre_char == '<' && nxt_char == '>'
		return del_pair
	elseif pre_char == '"' && nxt_char == '"'
		return del_pair
	elseif pre_char == "'" && nxt_char == "'"
		return del_pair
	elseif pre_char == '`' && nxt_char == '`'
		return del_pair
	else
		return "\<BS>"
	endif
endfunc


"--- tabulator ---"
"autocmd FileType h,c,cpp,java,python inoremap <S-TAB> <C-r>=Tabulator()<CR>

func! Tabulator()
    if strlen(getline('.')) < 1
        return "\<BS>\<CR>"
    else
        return "\<TAB>"
    endif
endfunc


"--- before saving ---"
autocmd BufWritePre * call Before_Saving()

func! Before_Saving()
    " delete trailing white space
    exec "%s/\s\+$//e"
    " delete trailing blank lines
    let ln_nb = prevnonblank('$')
    let ln_eof = line('$')
    if ln_eof > ln_nb + 1
        exec (ln_nb + 1) . "," . ln_eof . "d"
    endif
    " add 1 trailing blank line
    if prevnonblank('$') == line('$')
        call append(line('$'), "")
    endif
endfunc

