" vimrc
let s:is_windows = has("win32") || has("win64") || has("win95") || has("win16")
let s:is_macos = has("macunix")
if s:is_windows
	" windows
	let s:vimcfgp = expand('$HOME/vimfiles')
else
	" linux or macos
	let s:vimcfgp = expand('~/.vim')
endif


"--- Vundle ---"
set nocompatible " must
filetype off     " must, temporarily close, will re-open later
let &rtp = &rtp . ',' . expand(s:vimcfgp . '/bundle/Vundle.vim')
call vundle#begin(expand(s:vimcfgp . '/bundle'))
Plugin 'VundleVim/Vundle.vim'

"--- comment
Plugin 'tpope/vim-commentary'
" Plugin 'https://gitee.com/bigfacecat924/vim-commentary'

"--- file explorer
Plugin 'preservim/nerdtree'
" Plugin 'https://gitee.com/xie-xiaopeng/nerdtree'

"--- python
Plugin 'Vimjas/vim-python-pep8-indent'
" Plugin 'https://gitee.com/tyloeng/vim-python-pep8-indent'
Plugin 'tell-k/vim-autopep8'

"--- dos batch
Plugin 'vim-scripts/dosbatch-indent'

"--- BeanCount accounting syntax highlight
Plugin 'nathangrigg/vim-beancount'

"--- docker & sigularity
Plugin 'ekalinin/Dockerfile.vim'
Plugin 'rbberger/vim-singularity-syntax'

" Plugin 'jiangmiao/auto-pairs'
" Plugin 'https://gitee.com/rulei_mirror/auto-pairs'

"--- vim themes
Plugin 'altercation/solarized'
" Plugin 'https://gitee.com/liazpg/solarized'
" Plugin 'tomasiser/vim-code-dark'
" Plugin 'https://gitee.com/bigfacecat924/vim-code-dark'

"--- fzf fuzzy finding
Plugin 'junegunn/fzf'
Plugin 'junegunn/fzf.vim'
call vundle#end()         " must
filetype plugin indent on " must, here


"--- Settings ---"
set autoread " auto-reload file if modified elsewhere
set autochdir " change working path to current path
set backspace=indent,eol,start
let mapleader = '\'
"--- backup
set nobackup " don't create backup files
let &backupdir = s:vimcfgp . '/backup'
if !isdirectory(&backupdir)
	call mkdir(&backupdir, "p", 0700)
endif
"--- undo
" set noundofile " don't create .un~ files
let &undodir = s:vimcfgp . '/undo'
if !isdirectory(&undodir)
	call mkdir(&undodir, "p", 0700)
endif
"--- search
set hlsearch " highlight matched string
set incsearch " real-time match highlighting
set ignorecase " ignore case in search
set smartcase " but not ignore if search has uppercase
"--- add search path of some executables
if s:is_windows
	" for fzf. Suppose fzf.exe lies at D:/GnuWin32/bin/fzf.exe
	set rtp+=D:/GnuWin32/bin
endif


"--- Comment String (tpope/vim-commentary) ---"
" default: #(space)
"setlocal commentstring=#\ %s
" C/C++、Java: //(space)
autocmd FileType c,cpp,java setlocal commentstring=//\ %s
" python、shell: #(space)
autocmd FileType python,sh,ps1 setlocal commentstring=#\ %s
" lua、sql: --(space)
autocmd FileType lua,sql setlocal commentstring=--\ %s
" matlab: %(space)
autocmd FileType matlab,tex setlocal commentstring=%\ %s
" dosbatch: @REM(space)
autocmd FileType dosbatch setlocal commentstring=\@REM\ %s
" beancount: ;(space)
autocmd FileType beancount setlocal commentstring=;\ %s


"--- Encoding ---"
set encoding=utf-8
set fileencoding=utf-8
if s:is_windows
	"set termencoding=chinese " chinese is a variable
	source $VIMRUNTIME/delmenu.vim
	source $VIMRUNTIME/menu.vim
	"language messages zh_CN.utf-8
	"language messages none
	"set langmenu=none
endif
"set fileformats=unix,dos
"set fileformat=unix " use `\n`
"set fileformat=dos " use `\r\n`


"--- Tab ---"
set tabstop=4 " 1 tab = 4 spaces
set softtabstop=4
set shiftwidth=4
set smartindent
set cindent " C/C++-style indent
set noexpandtab " don't convert tabs to spaces by default
autocmd FileType python set expandtab " convert if Python
autocmd FileType xml,html call Setup_XHTML()
function Setup_XHTML()
	" tab of xml/html
	set tabstop=2
	set softtabstop=2
	set shiftwidth=2
endfunction


"--- Formatting ---"
noremap <F8> gg=G
inoremap <F8> <ESC>gg=G
vnoremap <F8> <ESC>gg=G
" for python: https://github.com/tell-k/vim-autopep8
" dependency: `pip install autopep8`
autocmd FileType python noremap <F8> :Autopep8<CR>|
	inoremap <F8> <ESC>:Autopep8<CR>|
	vnoremap <F8> <ESC>:Autopep8<CR>
let g:autopep8_max_line_length=150
let g:autopep8_disable_show_diff=1
"let g:autopep8_on_save=1


"--- ctags ---"
set tags=./tags,tags;$HOME
set tagcase=match


"--- Theme ---"
syntax enable
syntax on
set number " show line number
set ruler " show position
set showcmd " show command
set showmode " show mode
set showmatch " show matching parenthesis
set cursorline " highlight current line
if s:is_windows
	set t_Co=256	" for codedark theme
	set t_ut=		" for codedark theme
	if has ("gui_running") " gVim
		colorscheme solarized
	else " vim
		colorscheme desert
	endif
	set guifont=Consolas:h13:cANSI " English font
	set guifontwide=YouYuan:h13 " Chinese font
endif
set listchars=precedes:«,extends:»,tab:\|\ ,eol:┐,space:·
"set list " show special characters
highlight SpecialKey guifg=gray ctermfg=darkgray
highlight NonText guifg=gray ctermfg=darkgray


"--- GUI Initialisation  ---"
autocmd GUIEnter * call Init_GUI()

func! Init_GUI()
	"" config window
	set guioptions-=m			" hide menu
	set guioptions-=T			" hide tool bar
	" simalt ~x					" maximise window
	set lines=32 columns=110	" window size

	"" adjust background light/dark along time
	" dawn
	let dawn_hour = 6
	let dawn_minute = 30
	" evening / night
	let night_hour = 17
	let night_minute = 30
	" now
	let hour = strftime('%H')
	let minute = strftime('%M')
	" echo hour . ":" . minute
	if hour < dawn_hour
		set background=dark
	elseif (hour == dawn_hour) && (minute < dawn_minute)
		set background=dark
	elseif hour < night_hour
		set background=light
	elseif (hour == night_hour) && (minute < night_minute)
		set background=light
	else
		set background=dark
	endif
endfunc


"--- Buffer / Window Tab ---"
" to next buffer
noremap <C-Left> gT
inoremap <C-Left> <ESC>gTa
vnoremap <C-Left> <ESC>gT
" to previous buffer
noremap <C-Right> gt
inoremap <C-Right> <ESC>gta
vnoremap <C-Right> <ESC>gt
" open new buffer (prompt)
noremap <C-t> :tabe<Space>
inoremap <C-t> <ESC>:tabe<Space>
vnoremap <C-t> <ESC>:tabe<Space>
" close current buffer
" `Ctrl-w` conflicts with window switching
"noremap <C-w> :q<CR>
"inoremap <C-w> <ESC>:q<CR>
"vnoremap <C-w> <ESC>:q<CR>

"--- NERDTree (preservim/nerdtree) ---"
" F2 toggle open/close
noremap <F2> :NERDTreeToggle<CR>
inoremap <F2> <ESC>:NERDTreeToggle<CR>
" Ctrl + F2 open specific directory (prompt)
noremap <C-F2> :NERDTree
inoremap <C-F2> <ESC>:NERDTree


"--- Code Folding ---"
let &viewdir = s:vimcfgp . '/view' " put view files in viewdir
if !isdirectory(&viewdir)
	call mkdir(&viewdir, "p", 0700)
endif
set foldenable " enable code folding
set foldmethod=manual " manual folding creating with `zf` command
" Ctrl-f toggle open/collapse <- {zo: open, zc: collapse}
nnoremap <C-f> @=((foldclosed(line('.')) < 0) ? 'zc':'zo')<CR>
" auto save & load folding (i.e. view)
autocmd BufWinLeave ?* mkview
autocmd VimLeavePre ?* mkview
autocmd BufWinEnter ?* silent loadview
set foldlevel=1 " open folds up to level 1 when file opened
set foldlevelstart=1 " open folds up to level 1 when file opened
" set foldnestmax=3 " maximum fold level of 3
" set foldminlines=2 " minimum lines for a fold
" set fillchars=fold:\· " show `·` for folded lines


"--- select all ---"
inoremap <C-a> <ESC>ggvG$
noremap <C-a> ggvG$

"--- Window Swapping ---"
nmap <silent> <leader>mw :call MarkWindowSwap()<CR>
nmap <silent> <leader>pw :call DoWindowSwap()<CR>

function! MarkWindowSwap()
	let g:markedWinNum = winnr()
endfunction

function! DoWindowSwap()
	"Mark destination
	let curNum = winnr()
	let curBuf = bufnr( "%" )
	exe g:markedWinNum . "wincmd w"
	"Switch to source and shuffle dest->source
	let markedBuf = bufnr( "%" )
	"Hide and open so that we aren't prompted and keep history
	exe 'hide buf' curBuf
	"Switch to dest and shuffle source->dest
	exe curNum . "wincmd w"
	"Hide and open so that we aren't prompted and keep history
	exe 'hide buf' markedBuf
endfunction


"--- F9 compile & run ---"
noremap <F9> :call Compile_iTom()<CR>
inoremap <F9> <ESC>:call Compile_iTom()<CR>

func! Compile_iTom()
	exec "w"
	if &filetype == 'c'
		exec "! gcc % -o %<"
		exec "! ./%<"
	elseif &filetype == 'cpp'
		exec "! g++ % -o %<"
		exec "! ./%<"
	elseif &filetype == 'java'
		exec "! javac %"
		exec "! java %<"
	elseif &filetype == 'python'
		exec "! python %"
	elseif &filetype == 'matlab'
		exec "! octave %"
	elseif &filetype == 'sh'
		exec "! bash %"
	elseif &filetype == 'dosbatch'
		exec "! %"
	elseif &filetype == 'ps1'
		exec "! powershell -executionpolicy bypass -File %"
	endif
endfunc


"--- < & > ---"
autocmd FileType xml,html inoremap < <lt>><Left>|
	inoremap > <C-r>=Close_Pair('>')<CR>


"--- open pair ---"
inoremap ( <C-r>=Open_Pair('(', ')')<CR>
inoremap [ <C-r>=Open_Pair('[', ']')<CR>
inoremap { <C-r>=Open_Pair('{', '}')<CR>

func! Open_Pair(open, close)
	let line = getline('.')
	let nxt_char = line[col('.') - 1]
	if col('.') > strlen(line) || nxt_char == ' '
		return a:open.a:close."\<Left>"
	elseif nxt_char == a:close
		return a:open
	elseif nxt_char == ')' || nxt_char == ']' || nxt_char == '}'
		return a:open.a:close."\<Left>"
	else
		return a:open
	endif
endfunc


"--- close pair ---"
inoremap ) <C-r>=Close_Pair(')')<CR>
inoremap ] <C-r>=Close_Pair(']')<CR>
inoremap } <C-r>=Close_Pair('}')<CR>

func! Close_Pair(char)
	if getline('.')[col('.') - 1] == a:char
		return "\<Right>"
	else
		return a:char
	endif
endfunc


"--- quote ---"
inoremap " <C-r>=Same_Pair('"')<CR>
inoremap ' <C-r>=Same_Pair("'")<CR>
inoremap ` <C-r>=Same_Pair('`')<CR>

func! Same_Pair(char)
	let line = getline('.')
	let pair = a:char.a:char."\<Left>"
	if col('.') > strlen(line) " || line[col('.') - 1] == ' '
		return pair
	elseif line[col('.') - 1] == a:char
		return "\<Right>"
	else
		let pre_char = line[col('.') - 2]
		let nxt_char = line[col('.') - 1]
		if pre_char == '(' && nxt_char == ')'
			return pair
		elseif pre_char == '[' && nxt_char == ']'
			return pair
		elseif pre_char == '{' && nxt_char == '}'
			return pair
		elseif pre_char == '<' && nxt_char == '>'
			return pair
		else
			return a:char
		endif
	endif
endfunc


"--- carrage return ---"
autocmd FileType h,c,cpp,java,python,sh,dosbatch inoremap <CR> <C-r>=Carrage_Return()<CR>

func! Carrage_Return()
	let line = getline('.')
	let pre_char = line[col('.') - 2]
	let nxt_char = line[col('.') - 1]
	if pre_char == '(' && nxt_char == ')'
		if &filetype == 'dosbatch' || &filetype == 'python'
			return "\<CR>\<Up>\<ESC>A\<CR>"
		endif
	elseif pre_char == '[' && nxt_char == ']'
		if &filetype == 'python'
			return "\<CR>\<Up>\<ESC>A\<CR>"
		endif
	elseif pre_char == '{' && nxt_char == '}'
		return "\<CR>\<Up>\<ESC>A\<CR>"
	endif
	return "\<CR>"
endfunc


"--- backspace ---"
inoremap <BS> <C-r>=Back_Space()<CR>

func! Back_Space()
	let line = getline('.')
	let pre_char = line[col('.') - 2]
	let nxt_char = line[col('.') - 1]
	let del_pair = "\<BS>\<DEL>"
	if pre_char == '(' && nxt_char == ')'
		return del_pair
	elseif pre_char == '[' && nxt_char == ']'
		return del_pair
	elseif pre_char == '{' && nxt_char == '}'
		return del_pair
	elseif pre_char == '<' && nxt_char == '>'
		return del_pair
	elseif pre_char == '"' && nxt_char == '"'
		return del_pair
	elseif pre_char == "'" && nxt_char == "'"
		return del_pair
	elseif pre_char == '`' && nxt_char == '`'
		return del_pair
	else
		return "\<BS>"
	endif
endfunc


"--- tabulator ---"
"autocmd FileType h,c,cpp,java,python inoremap <S-TAB> <C-r>=Tabulator()<CR>

func! Tabulator()
	if strlen(getline('.')) < 1
		return "\<BS>\<CR>"
	else
		return "\<TAB>"
	endif
endfunc


"--- before saving ---"
autocmd BufWritePre * call Before_Saving()

func! Before_Saving()
	" delete trailing white space
	exec "%s/\\s\\+$//e"

	" retab leadning space/tab
	if 0 == &expandtab
		" adjust the # of space after `@<=` according to `tabstop`
		let retabcmd = "silent! %s/\\(^\\s*\\)\\@<=" . repeat(' ', &tabstop) . "/\\t/g"
	else " expandtab
		let retabcmd = "silent! %s/\\(^\\s*\\)\\@<=\\t/" . repeat(' ', &tabstop) . "/g"
	endif
	exec retabcmd

	" prettify comments: enforce a following space right after the comment symbol
	if &filetype == "python"
		exec "silent! %s/^\\(\\s*#\\) \\@!/\\1 /g"
	elseif &filetype == "sh"
		exec "silent! %s/^\\(\\s*#\\) \\@! !\\@!/\\1 /g"
	elseif &filetype == "c" || &filetype == "cpp" || &filetype == "java"
		exec "silent! %s/^\\(\\s*\\/\\/\\) \\@!/\\1 /g"
	elseif &filetype == "tex" || &filetype == "matlab"
		exec "silent! %s/^\\(\\s*%\\) \\@! !\\@!/\\1 /g"
	elseif &filetype == "sql" || &filetype == "lua"
		exec "silent! %s/^\\(\\s*--\\) \\@! !\\@!/\\1 /g"
	endif

	" delete trailing blank lines
	let ln_nb = prevnonblank('$')
	let ln_eof = line('$')
	if ln_eof > ln_nb + 1
		exec (ln_nb + 1) . "," . ln_eof . "d"
	endif
	" add 1 trailing blank line
	if prevnonblank('$') == line('$')
		call append(line('$'), "")
	endif
endfunc


"--- highlight current word ---"
" From: https://stackoverflow.com/questions/25227281/how-to-auto-highlight-the-current-word-in-vim
" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Type z/ to toggle highlighting on/off.
nnoremap z/ :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
function! AutoHighlightToggle()
	let @/ = ''
	if exists('#auto_highlight')
		au! auto_highlight
		augroup! auto_highlight
		setl updatetime=4000
		echo 'Highlight current word: off'
		return 0
	else
		augroup auto_highlight
			au!
			au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
		augroup end
		setl updatetime=500 " after how long of cursor hold before highlighting
		echo 'Highlight current word: ON'
		return 1
	endif
endfunction
